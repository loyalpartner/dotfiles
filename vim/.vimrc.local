""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
" vim 配置文件
"
"   1. 默认配置
"
" @author : 李凯
" @date : 2014-12-06 17:36
"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" 默认配置"{{{

  if has("unix")
    set guifont=Ubuntu\ Mono\ 12
  endif

  if has("gui_running")
    colorscheme molokai
    set guioptions-=r
    set guioptions-=L
  else
    colorscheme molokai
    "colorscheme tango-desert
  endif

  set dictionary+=/usr/share/dict/words
  set complete+=k
  set tabstop=2
  set shiftwidth=2
  set softtabstop=2

  imap <C-Z> <C-O><C-Y>

  " 改键
  noremap <Space> :

  noremap <C-c> <Esc><Esc>
  inoremap <C-c> <Esc><Esc>
  snoremap <C-c> <Esc><Esc>
  inoremap <nowait>  hh <Esc><Esc>
  snoremap <nowait>  hh <Esc><Esc>

  imap <C-g><C-A> <Home>
  imap <C-g><C-E> <End>

  " 移动窗口
  nnoremap <C-h> <C-w>h
  nnoremap <C-j> <C-w>j
  nnoremap <C-k> <C-w>k
  nnoremap <C-l> <C-w>l

  " di, 删除两个逗号之间的内容
  " da, 删除两个逗号以及之间的内容
  onoremap <silent> i, :<C-U>normal! T,vt,<CR>
  onoremap <silent> a, :<C-U>normal! F,vf,<CR>

  noremap <Leader>w :w<CR>

  nnoremap <leader>S mz^vg_y:execute @@<CR>`z
  vnoremap <leader>S mzy:execute @@<CR>`z
"}}}

" 解决textobj_quote在markdown的输入Bug""
autocmd! FileType markdown call textobj#quote#init({ 'double': '""', 'single': "''"})


""{{{ Tab匹配(,{,<
" @see http://www.ibm.com/developerworks/cn/linux/l-vim-script-3/index.html
" Table of completion specifications (a list of lists)...
let s:completions = []
" Function to add user-defined completions...
function! AddCompletion (left, right, completion, restore)
  call insert(s:completions, [a:left, a:right, a:completion, a:restore])
endfunction

" Table of completions...
"                    Left   Right    Complete with...       Restore
"                    =====  =======  ====================   =======
let s:NONE = ""
call AddCompletion(  '{',   s:NONE,  "}",                      1    )
call AddCompletion(  '{',   '}',     "\<CR>\<C-D>\<ESC>O",     0    )
call AddCompletion(  '\[',  s:NONE,  "]",                      1    )
call AddCompletion(  '\[',  '\]',    "\<CR>\<ESC>O\<TAB>",     0    )
call AddCompletion(  '(',   s:NONE,  ")",                      1    )
call AddCompletion(  '(',   ')',     "\<CR>\<ESC>O\<TAB>",     0    )
call AddCompletion(  '<',   s:NONE,  ">",                      1    )
call AddCompletion(  '<',   '>',     "\<CR>\<ESC>O\<TAB>",     0    )
call AddCompletion(  '"',   s:NONE,  '"',                      1    )
call AddCompletion(  '"',   '"',     "\\n",                    1    )
call AddCompletion(  "'",   s:NONE,  "'",                      1    )
call AddCompletion(  "'",   "'",     s:NONE,                   0    )

" Implement smart completion magic...
function! SmartComplete ()
  " Remember where we parked...
  let cursorpos = getpos('.')
  let cursorcol = cursorpos[2]
  let curr_line = getline('.')

  " Special subpattern to match only at cursor position...
  let curr_pos_pat = '\%' . cursorcol . 'c'

  " Tab as usual at the left margin...
  if curr_line =~ '^\s*' . curr_pos_pat
    return "\<TAB>"
  endif

  " How to restore the cursor position...
  let cursor_back = "\<C-O>:call setpos('.'," . string(cursorpos) . ")\<CR>"

  " If a matching smart completion has been specified, use that...
  for [left, right, completion, restore] in s:completions
    let pattern = left . curr_pos_pat . right
    if curr_line =~ pattern
      " Code around bug in setpos() when used at EOL...
      if cursorcol == strlen(curr_line)+1 && strlen(completion)==1 
        let cursor_back = "\<LEFT>"
      endif

      " Return the completion...
      return completion . (restore ? cursor_back : "")
    endif
  endfor

  " If no contextual match and after an identifier, do keyword completion...
  if curr_line =~ '\k' . curr_pos_pat
    return "\<C-N>"

    " Otherwise, just be a <TAB>...
  else
    return "\<TAB>"
  endif
endfunction

" Remap <TAB> for smart completion on various characters...
"inoremap <silent> <TAB>   <C-R>=SmartComplete()<CR>
"}}}
" Fcitx输入法在Normal模式切换为英文状态"{{{
if has("unix")
  function! FcitxNormal()
    if system("fcitx-remote")==2
      call system("fcitx-remote -c")
    endif
  endfunction

  " 按键都会有一个延迟, 最开始由于对 vim 理解不够, 想到每次离开插入模式的
  " 时候把 timeoutlen 设置成一个很小的值，其实不需要这样，
  "  noremap hh <Esc><Esc>
  autocmd InsertLeave * :call FcitxNormal()
  "autocmd InsertLeave * :call FcitxNormal() | execute "set timeoutlen&"
  "autocmd InsertEnter * execute "set timeoutlen=300"
endif"}}}
" 自定义 Tabline {{{ 

hi TabLine      ctermfg=Black  ctermbg=Green     cterm=NONE
hi TabLineFill  ctermfg=Black  ctermbg=Green     cterm=NONE
hi TabLineSel   ctermfg=White  ctermbg=DarkBlue  cterm=NONE

command! -count=0 GotoTabpage call GotoRevertTabpage()
function! GotoRevertTabpage()
    if v:count == 0
      silent execute 'normal! gT'
    else
      silent execute 'normal! '. (tabpagenr('$') - (v:count - 1)) . 'gt'
    endif
endfunction
nnoremap <silent> gT :GotoTabpage<CR>
"}}}

nnoremap ,ns :vs ~/.vim/bundle/vim-snippets/snippets/<C-r>=&filetype<CR>.snip<CR>
nnoremap ,nS :vs ~/.vim/bundle/vim-snippets/snippets/<C-r>=&filetype<CR>.snippets<CR>
nnoremap ,ne :vs ~/.vim/bundle/vim-snippets/snippets/
nnoremap ,nl :NeoSnippetSource ~/.vim/bundle/vim-snippets/snippets/

nnoremap <F5> :silent so ~/.vimrc.local<cr>
noremap <Leader>= :execute "normal! ggVG=``"<CR>
"nnoremap <C-p> :<C-U>CtrlPMixed<CR>

" vim: set foldmethod=marker tabstop=2 shiftwidth=2 softtabstop=2 expandtab:
